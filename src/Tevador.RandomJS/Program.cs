/*
    (c) 2018 tevador <tevador@gmail.com>

    This file is part of Tevador.RandomJS.

    Tevador.RandomJS is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Tevador.RandomJS is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Tevador.RandomJS.  If not, see<http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Linq;
using System.Net;
using Tevador.RandomJS.Operators;

namespace Tevador.RandomJS
{
    class Program : Block, IProgram
    {
        private Dictionary<string, Global> _globalNames = new Dictionary<string, Global>();
        private List<Global> _globals = new List<Global>();
        private List<Variable> _printOrder;
        private ProgramOptions _options;

        public Program()
            : base(null)
        {

        }

        public override void Require(Global gl)
        {
            if (!_globalNames.ContainsKey(gl.Name))
            {
                _globalNames.Add(gl.Name, gl);
                var gfunc = gl as GlobalFunction;
                if (gfunc?.References != null)
                {
                    Require(gfunc.References);
                }
                _globals.Add(gl);
            }
        }

        public override ProgramOptions Options
        {
            get { return _options; }
        }

        private void SetGlobalVariable<T>(string name, T value)
        {
            Global g;
            if (value != null && _globalNames.TryGetValue(name, out g))
            {
                GlobalVariable glVar = g as GlobalVariable;
                if (glVar != null)
                {
                    glVar.Initializer = new Expressions.Literal(value.ToString());
                }
            }
        }

        public Program Generate(IRandom rand, ProgramOptions options)
        {
            _options = options;
            rand.Seed(options.Seed);
            if (_options.DepthProtection != null)
                _options.DepthProtection?.AttachTo(this);
            while (_declaredVariables.Count < options.GlobalVariablesCount)
            {
                _declaredVariables.Add(Variable.Generate(rand, this, false, false));
            }
            _printOrder = new List<Variable>(_declaredVariables);
            rand.Shuffle(_printOrder);
            foreach (var v in _printOrder)
            {
                _statements.Add(OutputStatement.Generate(rand, this, v));
            }
            SetGlobalVariable(GlobalFunction.STRL.References.Name, _options.MaxStringVariableLength);
            SetGlobalVariable(GlobalFunction.PREC.References.Name, _options.FpMathPrecision);
            return this;
        }

        public override void WriteTo(System.IO.TextWriter w)
        {
            w.WriteLine("/* This program was generated by Tevador.RandomJS */");
            w.WriteLine("/* {0} */", _options);
            w.WriteLine("/* globals: */");
            foreach (var gf in _globals)
            {
                gf.WriteTo(w);
            }
            w.WriteLine("/* Print order: {0} */", string.Join(", ", _printOrder));
            base.WriteTo(w);
        }

        // 4,86236203379662 ms per seed
        // Runtime: Min: 2,1137; Max: 22,169; Avg: 3,90796864137288; Stdev: 1,87134841989214;
        public int Execute(out string output, out string error)
        {
            StringBuilder sb = new StringBuilder(10000);
            using (var writer = new StringWriter(sb))
            {
                WriteTo(writer);
            }
            try
            {
                HttpWebRequest request = (HttpWebRequest)WebRequest.Create("http://localhost:18111");
                request.KeepAlive = false;
                request.Timeout = 10000;
                request.Method = "POST";
                byte[] data = Encoding.UTF8.GetBytes(sb.ToString());
                request.ContentLength = data.Length;
                Stream reqStream = request.GetRequestStream();
                reqStream.Write(data, 0, data.Length);
                reqStream.Close();
                WebResponse response = request.GetResponse();
                using (StreamReader reader = new StreamReader(response.GetResponseStream()))
                {
                    output = reader.ReadToEnd();
                }
                error = null;
                return 0;
            }
            catch(WebException e)
            {             
                output = null;
                var response = e.Response as HttpWebResponse;
                if (response != null)
                {
                    error = new StreamReader(response.GetResponseStream()).ReadToEnd();
                    return (int)response.StatusCode;
                }
                else
                {
                    error = e.Message;
                    return e.HResult;
                }
            }
        }

        public byte[] Seed
        {
            get { return _options.Seed; }
        }

        static unsafe byte[] GenerateSeed(int init)
        {
            ulong smallSeed = (ulong)init;
            byte[] bigSeed = new byte[4 * sizeof(ulong)];
            fixed (byte* buffer = bigSeed)
            {
                ulong* s = (ulong*)buffer;
                s[0] = Xoshiro256Plus.SplitMix64(ref smallSeed);
                s[1] = Xoshiro256Plus.SplitMix64(ref smallSeed);
                s[2] = Xoshiro256Plus.SplitMix64(ref smallSeed);
                s[3] = Xoshiro256Plus.SplitMix64(ref smallSeed);
            }
            return bigSeed;
        }

        static void MakeStats(IRandom random, ProgramOptions options)
        {
            const int count = 10000;
            var runtimes = new List<double>(count);

            var sw = Stopwatch.StartNew();
            var runtimeSw = new Stopwatch();
            for (int i = 0; i < count; ++i)
            {
                var seed = Environment.TickCount + i;
                Console.WriteLine("Seed = {0}", seed);
                options.Seed = GenerateSeed(seed);
                var p = new Program();
                p.Generate(random, options);
                runtimeSw.Restart();
                string output, error;
                var exitCode = p.Execute(out output, out error);
                runtimeSw.Stop();
                if (exitCode != 0)
                {
                    Console.WriteLine($"// ExitCode = {exitCode}");
                    Console.WriteLine(output);
                    Console.WriteLine(error);
                    break;
                }
                runtimes.Add(runtimeSw.Elapsed.TotalMilliseconds);
            }
            sw.Stop();

            Console.WriteLine($"// {count} seeds processed in {sw.Elapsed.TotalSeconds} seconds");

            runtimes.Sort();
            runtimes.RemoveAt(0);
            runtimes.RemoveAt(runtimes.Count - 1);
            var avg = runtimes.Average();
            var min = runtimes[0];
            var max = runtimes[runtimes.Count - 1];
            var sqsum = runtimes.Sum(d => (d - avg) * (d - avg));
            var stdev = Math.Sqrt(sqsum / runtimes.Count);
            Console.WriteLine($"Runtime: Min: {min}; Max: {max}; Avg: {avg}; Stdev: {stdev};");
            int[] histogram = new int[(int)Math.Ceiling((max - min) / stdev * 10)];
            foreach (var run in runtimes)
            {
                histogram[(int)(((run - min) / stdev * 10))]++;
            }
            Console.WriteLine("Histogram:");
            for (int j = 0; j < histogram.Length; ++j)
            {
                Console.WriteLine(string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0} {1}", j * stdev / 10 + min, histogram[j]));
            }
        }

        static void Main(string[] args)
        {
            int seed = Environment.TickCount;
            if (args.Length > 0 && !int.TryParse(args[0], out seed))
            {
                Console.WriteLine("Invalid seed value");
                return;
            }
            var random = new Xoshiro256Plus();
            var p = new ProgramFactory(random).GenProgran(GenerateSeed(seed));
            p.WriteTo(Console.Out);
            Console.WriteLine($"// {random.Counter} random numbers used");
        }
    }
}
